Теория — статический и динамический тип указателя или ссылки на объект

Рассмотрим простой код

struct Parent {
  virtual string Name() const { return "Parent"; }
};

struct Child : Parent {
  virtual string Name() const override { return "Child"; }
};

void Print(const Parent& object) {
  cout << object.Name() << '\n';
}

int main() {
  Print(Parent());
  Print(Child());
}

Если у вас спросить, какой тип имеет параметр object функции Print, вы наверняка ответите «const Parent&» и будете правы. 
А если мы спросим, на объект какого типа ссылается параметр object, то правильным будет ответ: «Зависит от того, какой объект передали в функцию Print».

Получается, с одной стороны, мы знаем, какой тип имеет параметер object, но с другой стороны, мы не можем точно сказать, на объект какого типа он ссылается. В этом и состоит разница между статическим и динамическим типом ссылки (или указателя) на класс, у которого могут быть наследники.

Статический тип ссылки — это тип, известный на этапе компиляции. В нашем примере статический тип параметра object — это const Parent&.

Динамический тип ссылки — это тип объекта, на который она ссылается в данный момент времени. Динамическим типом параметра object во время первого вызова 
функции Print будет const Parent, во время второго вызова функции Print — const Child.

Теория — тип указателя this в классах-наследниках

Теперь давайте рассмотрим другой пример. Как вы думаете, что будет выведено на экран?

struct Parent;
struct Child;

void PrintType(Parent*) { cout << "Parent\n"; }
void PrintType(Child*) { cout << "Child\n"; }

struct Parent {
  virtual void Print() { PrintType(this); }
};

struct Child : Parent {
};

int main() {
  Child().Print();
}

Вариантов, на самом деле, всего два, и правильный — это «Parent». 
Несмотря на то, что мы создали объект типа Child, указатель this внутри методов класса Parent имеет тип Parent*, а не Child*, как могло бы показаться. 
И это логично, потому что:
- выбор, какая из двух функций PrintType будет вызвана из метода Parent::Print, осуществляется на этапе компиляции; 
  в этот момент компилятор наверняка знает только одно — что указатель this будет указывать на объект класса Parent
- виртуальными (то есть зависящими от динамического типа) в C++ могут быть только методы, а this — это лишь указатель.

Наконец, рассмотрим ещё один пример и снова зададимся вопросом, что он выведет:

struct Parent;
struct Child;

void PrintType(Parent*) { cout << "Parent\n"; }
void PrintType(Child*) { cout << "Child\n"; }

struct Parent {
  virtual void Print() { PrintType(this); }
};

struct Child : Parent {
  void Print() override { PrintType(this); }
};

int main() {
  Child().Print();
}

Мы переопределили метод Print в классе Child, оставив у него точь-в-точь такую же реализацию, какая была в Parent::Print. 
Но кое-что изменилось — тип указателя this. Внутри метода Child::Print он имеет тип Child*. 
Причина та же — когда компилятор обрабатывает метод Child::Print, он знает, что this точно будет указывать на объект класса Child.

Итак, главный вывод — this всегда имеет тип указателя на тот класс, в методе которого он используется.
