Programming Assignment: operator[] в классе Polynomial

В лекциях мы наглядно продемонстрировали, что константность ограничивает набор операций, 
которые можно выполнять с объектом, защищая его от нежелательного изменения. 
Однако возможности константности ограничены, и в некоторых случаях она не позволяет достичь желаемого эффекта. 
В таких ситуациях на помощь приходит система типов, которая позволяет создавать классы с требуемыми свойствами. 
Мы рассмотрим такую ситуацию в этой задаче.

Вам дана реализация шаблона Polynomial, который представляет собой многочлен от одной переменной. 
Тип T этого шаблона задаёт тип коэффициентов и переменной. То есть Polynomial<int> -- это многочлен 
с целочисленными коэффициентами от целочисленной переменной, Polynomial<double> -- это многочлен 
с вещественными коэффициентами от вещественной переменной. Рассмотрим интерфейс класса Polynomial<T>:

template<typename T>
class Polynomial {
private:
  ...
public:
  // Принимает вектор коэффициентов (коэффициенты задаются от младшего к старшим)
  // Например, Polynomial({10, 2, 3, 4}) создаёт многочлен 4*x^3 + 3*x^2 + 2*x + 10
  Polynomial(vector<T> coeffs);

  // Создаёт многочлен, все коэффициенты которого равны нулю
  Polynomial();

  // Аналогичен конструктору от вектора, но принимает пару итераторов
  template<typename Iterator>
  Polynomial(Iterator first, Iterator last);

  // Операторы проверки на равенство и неравенство. Два многочлена равны тогда и только тогда,
  // когда их соответствующие коэффициенты попарно равны
  bool operator ==(const Polynomial& other) const;
  bool operator !=(const Polynomial& other) const;

  // Возвращает степень многочлена -- максимальную степень, коэффициент при которой не равен нулю.
  // Например, степень многочлена 2*x равна 1, степень многочлена 4*x^5 + x^3 - 10 равна 5,
  // степень многочлена 5 равна нулю.
  // Метод работает за O(1)
  int Degree() const;

  Polynomial& operator +=(const Polynomial& r);
  Polynomial& operator -=(const Polynomial& r);

  // Возвращает значение коэффициента при заданной степени.
  // Если переданное значение больше степени многочлена, метод возвращает 0
  T operator [](size_t degree) const;
  // Вычисляет значение многочлена в точке с переданным значением
  T operator ()(const T& x) const;

  using const_iterator = typename std::vector<T>::const_iterator;

  // Итераторы на коэффициенты многочлена
  const_iterator begin() const;
  const_iterator end() const;
};

В приведённой выше реализации есть только одна возможность задать значения коэффициентов 
многочлена — передать их в конструктор. Однако на практике может оказаться полезной возможность 
задавать коэффициенты по одному (эта возможность особенно полезна для сильно разреженных полиномов): 

Polynomial<int> p;
p[1] = 5;
p[24] = -8;
p[61] = 12;
p[314] = 272;

Ваша задача -- добавить эту возможность, а именно реализовать неконстантный operator[] для шаблона Polynomial, 
который:
- будет позволять задавать значение коэффициента заданной степени (как в примере выше)
- будет позволять читать значение коэффициента заданной степени (то есть должен работать код int cv = p[4];)
- будет работать за O(1) в случае, если не меняется степень многочлена
- не будет менять степень многочлена, если запись не была произведена
Последнее требование можно выразить вот таким тестом:

olynomial<int> p;
p[2] = 1;
ASSERT_EQUAL(p.Degree(), 2);
int x = p[5];
ASSERT_EQUAL(x, 0);
ASSERT_EQUAL(p.Degree(), 2); // Мы ничего не записали в p[5], поэтому степень многочлена не изменилась

См. также юнит-тесты в заготовке решения

На проверку пришлите cpp-файл с полной реализацией шаблона Polynomial.

Заготовка решения: polynomial.cpp
